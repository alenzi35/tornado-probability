<canvas id="mapCanvas"></canvas>
<script>
const canvas = document.getElementById("mapCanvas");
const ctx = canvas.getContext("2d");

let features = [];
let scale = 1;
let offsetX = 0;
let offsetY = 0;
let dragging = false;
let lastX, lastY;

// Load JSON
fetch("map/data/tornado_prob_lcc.json")
  .then(r => r.json())
  .then(data => {
    features = data.features;
    // Compute bounds to center
    const xs = features.map(f => f.x);
    const ys = features.map(f => f.y);
    const minX = Math.min(...xs);
    const maxX = Math.max(...xs);
    const minY = Math.min(...ys);
    const maxY = Math.max(...ys);
    offsetX = canvas.width/2 - (minX+maxX)/2;
    offsetY = canvas.height/2 - (minY+maxY)/2;
    render();
  });

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  render();
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

canvas.addEventListener("mousedown", e => {
  dragging = true;
  lastX = e.clientX;
  lastY = e.clientY;
});
window.addEventListener("mouseup", () => dragging = false);
window.addEventListener("mousemove", e => {
  if(!dragging) return;
  const dx = e.clientX - lastX;
  const dy = e.clientY - lastY;
  offsetX += dx;
  offsetY += dy;
  lastX = e.clientX;
  lastY = e.clientY;
  render();
});

// Zoom
canvas.addEventListener("wheel", e => {
  e.preventDefault();
  const mouseX = e.clientX;
  const mouseY = e.clientY;
  const zoom = e.deltaY < 0 ? 1.1 : 0.9;
  offsetX = mouseX - (mouseX - offsetX) * zoom;
  offsetY = mouseY - (mouseY - offsetY) * zoom;
  scale *= zoom;
  scale = Math.min(Math.max(scale, 0.1), 20);
  render();
},{passive:false});

function render() {
  if(!features.length) return;
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.translate(offsetX, offsetY);
  ctx.scale(scale, scale);
  for(const f of features){
    const w = f.dx;
    const h = f.dy;
    const r = Math.floor(255*f.prob);
    const b = Math.floor(255*(1-f.prob));
    ctx.fillStyle = `rgb(${r},0,${b})`;
    ctx.fillRect(f.x - w/2, f.y - h/2, w, h);
  }
}
</script>
