<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>RAP Tornado Probability (LCC)</title>
<style>
  body { margin:0; overflow:hidden; }
  canvas { display:block; background:#111; }
  #tooltip {
    position:absolute;
    pointer-events:none;
    background:rgba(0,0,0,0.7);
    color:#fff;
    padding:4px 6px;
    border-radius:3px;
    font-family:sans-serif;
    font-size:12px;
    display:none;
  }
</style>
</head>
<body>
<canvas id="mapCanvas"></canvas>
<div id="tooltip"></div>

<script>
const canvas = document.getElementById('mapCanvas');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');

let width, height;
function resize() {
  width = window.innerWidth;
  height = window.innerHeight;
  canvas.width = width;
  canvas.height = height;
}
window.addEventListener('resize', resize);
resize();

let features = [];
let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

// Canvas transform state
let scale = 0.00005; // initial zoom factor
let offsetX = 0;
let offsetY = 0;
let isDragging = false;
let dragStart = {x:0, y:0};
let dragOffset = {x:0, y:0};

// Load JSON
fetch('map/data/tornado_prob_lcc.json')
  .then(r=>r.json())
  .then(data=>{
    features = data.features;

    // Compute bounds
    features.forEach(f=>{
      if(f.x<minX) minX=f.x; if(f.x>maxX) maxX=f.x;
      if(f.y<minY) minY=f.y; if(f.y>maxY) maxY=f.y;
    });

    // Center view
    offsetX = width/2 - (minX + maxX)/2 * scale;
    offsetY = height/2 + (minY + maxY)/2 * scale; // y-axis flip

    draw();
  });

// Draw function
function draw() {
  ctx.clearRect(0,0,width,height);

  features.forEach(f=>{
    const px = f.x*scale + offsetX;
    const py = -f.y*scale + offsetY;

    // Draw 13km square
    const cellSize = 13000*scale;
    const red = Math.floor(255*f.prob);
    const blue = Math.floor(255*(1-f.prob));
    ctx.fillStyle = `rgba(${red},0,${blue},0.7)`;
    ctx.fillRect(px-cellSize/2, py-cellSize/2, cellSize, cellSize);
  });
}

// ---------------- Zoom ----------------
canvas.addEventListener('wheel', e=>{
  e.preventDefault();
  const zoomFactor = Math.exp(-e.deltaY*0.001);
  const mouseX = e.offsetX;
  const mouseY = e.offsetY;

  // Zoom around mouse
  offsetX = mouseX - (mouseX - offsetX)*zoomFactor;
  offsetY = mouseY - (mouseY - offsetY)*zoomFactor;
  scale *= zoomFactor;
  draw();
});

// ---------------- Pan ----------------
canvas.addEventListener('mousedown', e=>{
  isDragging = true;
  dragStart = {x:e.clientX, y:e.clientY};
  dragOffset = {x: offsetX, y: offsetY};
});
window.addEventListener('mouseup', ()=>{isDragging=false;});
window.addEventListener('mousemove', e=>{
  if(isDragging){
    offsetX = dragOffset.x + (e.clientX - dragStart.x);
    offsetY = dragOffset.y + (e.clientY - dragStart.y);
    draw();
  }

  // Tooltip
  let found = false;
  for(let f of features){
    const px = f.x*scale + offsetX;
    const py = -f.y*scale + offsetY;
    const cellSize = 13000*scale;
    if(Math.abs(e.offsetX - px)<=cellSize/2 && Math.abs(e.offsetY - py)<=cellSize/2){
      tooltip.style.display='block';
      tooltip.style.left = e.pageX+10+'px';
      tooltip.style.top = e.pageY+10+'px';
      tooltip.innerHTML = `X: ${f.x.toFixed(0)} m<br>Y: ${f.y.toFixed(0)} m<br>Prob: ${f.prob.toFixed(3)}`;
      found = true;
      break;
    }
  }
  if(!found) tooltip.style.display='none';
});
</script>
</body>
</html>
