<!DOCTYPE html>
<html>
<head>
  <title>Tornado Probability Map</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

  <style>
    body { margin:0; font-family:Arial, sans-serif; background:#f4f4f4; }
    h1 { text-align:center; margin:10px 0; }
    #map { height:650px; margin:10px; border-radius:8px; }
    .leaflet-control.custom {
      background:white;
      padding:8px;
      border-radius:6px;
      box-shadow:0 0 6px rgba(0,0,0,0.3);
    }
    button { width:100%; margin:4px 0; cursor:pointer; }
  </style>
</head>
<body>

<h1>Tornado Probability Map</h1>
<div id="map"></div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
/* ============================
   CONSTANTS
============================ */

const CELL_SIZE = 13000;   // 13 km in meters
const AGG_SIZE  = 10;      // 10x10 cells

// fixed grid origin (southwest CONUS)
const GRID_ORIGIN_LAT = 24;
const GRID_ORIGIN_LON = -125;

/* ============================
   MAP SETUP
============================ */

const map = L.map('map', {
  minZoom: 4,
  maxZoom: 18,
  zoomSnap: 0.25
}).setView([39.5, -98.35], 4);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: 'Â© OpenStreetMap contributors'
}).addTo(map);

const aggregateLayer = L.layerGroup().addTo(map);
const cellLayer = L.layerGroup();

/* ============================
   GRID HELPERS
============================ */

const originMeters = L.CRS.EPSG3857.project(
  L.latLng(GRID_ORIGIN_LAT, GRID_ORIGIN_LON)
);

function snapToGrid(lat, lon) {
  const p = L.CRS.EPSG3857.project(L.latLng(lat, lon));
  return {
    i: Math.floor((p.x - originMeters.x) / CELL_SIZE),
    j: Math.floor((p.y - originMeters.y) / CELL_SIZE)
  };
}

function cellBounds(i, j) {
  const x0 = originMeters.x + i * CELL_SIZE;
  const y0 = originMeters.y + j * CELL_SIZE;
  return [
    L.CRS.EPSG3857.unproject(L.point(x0, y0)),
    L.CRS.EPSG3857.unproject(L.point(x0 + CELL_SIZE, y0 + CELL_SIZE))
  ];
}

/* ============================
   COLOR SCALE
============================ */

function getColor(p) {
  if (p > 0.8) return '#800026';
  if (p > 0.6) return '#BD0026';
  if (p > 0.4) return '#E31A1C';
  if (p > 0.2) return '#FC4E2A';
  return '#FFEDA0';
}

/* ============================
   DATA + INDEXING
============================ */

let gridCells = {};
let aggregates = {};

fetch("map/data/tornado_prob.json")
  .then(r => r.json())
  .then(data => {
    data.forEach(pt => {
      const { i, j } = snapToGrid(pt.lat, pt.lon);
      const key = `${i},${j}`;
      gridCells[key] = { i, j, prob: pt.prob };

      const ai = Math.floor(i / AGG_SIZE);
      const aj = Math.floor(j / AGG_SIZE);
      const akey = `${ai},${aj}`;

      if (!aggregates[akey]) aggregates[akey] = [];
      aggregates[akey].push({ i, j, prob: pt.prob });
    });

    drawAggregates();
  });

/* ============================
   DRAW AGGREGATES
============================ */

function drawAggregates() {
  aggregateLayer.clearLayers();
  cellLayer.clearLayers();

  Object.keys(aggregates).forEach(key => {
    const [ai, aj] = key.split(',').map(Number);

    const bounds = [
      L.CRS.EPSG3857.unproject(
        L.point(
          originMeters.x + ai * AGG_SIZE * CELL_SIZE,
          originMeters.y + aj * AGG_SIZE * CELL_SIZE
        )
      ),
      L.CRS.EPSG3857.unproject(
        L.point(
          originMeters.x + (ai+1) * AGG_SIZE * CELL_SIZE,
          originMeters.y + (aj+1) * AGG_SIZE * CELL_SIZE
        )
      )
    ];

    const rect = L.rectangle(bounds, {
      fillColor: '#999',
      fillOpacity: 0.25,
      color: '#000',
      weight: 1
    }).addTo(aggregateLayer);

    rect.on('dblclick', () => drawCells(key));
  });
}

/* ============================
   DRAW CELLS
============================ */

function drawCells(akey) {
  aggregateLayer.clearLayers();
  cellLayer.clearLayers();

  aggregates[akey].forEach(c => {
    L.rectangle(
      cellBounds(c.i, c.j),
      {
        fillColor: getColor(c.prob),
        fillOpacity: 0.45,
        weight: 0.2
      }
    )
    .addTo(cellLayer)
    .bindPopup(`Probability: ${(c.prob * 100).toFixed(2)}%`);
  });

  map.fitBounds(cellLayer.getBounds());
}

/* ============================
   BACK BUTTON
============================ */

L.control({position:'topleft'}).onAdd = function () {
  const div = L.DomUtil.create('div','leaflet-control custom');
  div.innerHTML = `<button id="back">Back to aggregates</button>`;
  div.onclick = () => drawAggregates();
  return div;
}.addTo(map);

</script>
</body>
</html>
