<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>RAP Tornado Probability (LCC)</title>

<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #111;
    overflow: hidden;
  }

  #mapCanvas {
    display: block;
  }

  #tooltip {
    position: fixed;
    background: rgba(0,0,0,0.8);
    color: #fff;
    font-family: monospace;
    font-size: 12px;
    padding: 6px 8px;
    border-radius: 4px;
    pointer-events: none;
    display: none;
    z-index: 10;
  }
</style>
</head>

<body>

<canvas id="mapCanvas"></canvas>
<div id="tooltip"></div>

<script>

const canvas = document.getElementById("mapCanvas");
const ctx = canvas.getContext("2d");
const tooltip = document.getElementById("tooltip");

let features = [];

let minX, maxX, minY, maxY;
let rangeX, rangeY;
let shiftX, shiftY;

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  if (features.length) {
    render();
  }
}

window.addEventListener("resize", resizeCanvas);
resizeCanvas();


/* ----------------------------
   Load Data
----------------------------- */

fetch("map/data/tornado_prob_lcc.json")
  .then(r => r.json())
  .then(data => {

    features = data.features;

    console.log("Loaded points:", features.length);
    console.log("Sample:", features[0]);

    computeBounds();
    render();

  })
  .catch(err => {
    console.error("JSON load failed:", err);
  });


/* ----------------------------
   Compute Bounds
----------------------------- */

function computeBounds() {

  minX = Infinity;
  maxX = -Infinity;
  minY = Infinity;
  maxY = -Infinity;

  features.forEach(f => {

    if (f.x < minX) minX = f.x;
    if (f.x > maxX) maxX = f.x;

    if (f.y < minY) minY = f.y;
    if (f.y > maxY) maxY = f.y;

  });

  rangeX = maxX - minX;
  rangeY = maxY - minY;

  shiftX = -minX;
  shiftY = -minY;

  console.log("Bounds:", { minX, maxX, minY, maxY });
}


/* ----------------------------
   Render
----------------------------- */

function render() {

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  features.forEach(f => {

    // Project to screen
    const px = ((f.x + shiftX) / rangeX) * canvas.width;
    const py = canvas.height -
               ((f.y + shiftY) / rangeY) * canvas.height;

    // True grid size
    const w = (f.dx / rangeX) * canvas.width;
    const h = (f.dy / rangeY) * canvas.height;

    // Color
    const red = Math.floor(255 * f.prob);
    const blue = Math.floor(255 * (1 - f.prob));

    ctx.fillStyle = `rgb(${red},0,${blue})`;

    // Draw cell
    ctx.fillRect(
      px - w / 2,
      py - h / 2,
      w,
      h
    );

  });

  console.log("Rendered.");
}


/* ----------------------------
   Hover Tooltip
----------------------------- */

canvas.addEventListener("mousemove", e => {

  if (!features.length) return;

  const rect = canvas.getBoundingClientRect();

  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  // Convert mouse to LCC
  const x =
    (mx / canvas.width) * rangeX - shiftX;

  const y =
    ((canvas.height - my) / canvas.height) * rangeY - shiftY;

  let best = null;
  let bestDist = Infinity;

  // Nearest neighbour search
  for (let f of features) {

    const dx = f.x - x;
    const dy = f.y - y;

    const d = dx*dx + dy*dy;

    if (d < bestDist) {
      bestDist = d;
      best = f;
    }
  }

  if (!best) return;

  tooltip.style.display = "block";
  tooltip.style.left = (e.clientX + 12) + "px";
  tooltip.style.top = (e.clientY + 12) + "px";

  tooltip.innerHTML =
    `Prob: ${(best.prob * 100).toFixed(1)}%<br>` +
    `X: ${best.x.toFixed(0)} m<br>` +
    `Y: ${best.y.toFixed(0)} m`;

});


canvas.addEventListener("mouseleave", () => {
  tooltip.style.display = "none";
});

</script>

</body>
</html>
