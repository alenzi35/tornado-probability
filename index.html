<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>RAP Tornado Probability (Mercator)</title>
<style>
  body { margin:0; overflow:hidden; }
  canvas { display:block; background:#111; }
  #tooltip {
    position:absolute;
    pointer-events:none;
    padding:4px 8px;
    background:rgba(0,0,0,0.8);
    color:#fff;
    font-family:sans-serif;
    font-size:12px;
    border-radius:4px;
    display:none;
  }
</style>
</head>
<body>
<canvas id="mapCanvas"></canvas>
<div id="tooltip"></div>

<script src="https://unpkg.com/proj4/dist/proj4.js"></script>
<script>
const canvas = document.getElementById('mapCanvas');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');

let data = null;
let scale = 1, offsetX = 0, offsetY = 0;
let isDragging = false, startDrag = {};

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Mercator projection helper
function mercatorXY(lat, lon) {
  const x = lon * 20037508.34 / 180;
  let y = Math.log(Math.tan((90 + lat) * Math.PI/360)) / (Math.PI/180);
  y = y * 20037508.34 / 180;
  return [x, y];
}

// Load JSON
fetch('map/data/tornado_prob.json')
  .then(res => res.json())
  .then(json => {
    data = json;

    // Compute bounds for initial scaling
    let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
    data.forEach(f => {
      const [x, y] = mercatorXY(f.lat, f.lon);
      if(x<minX) minX=x; if(x>maxX) maxX=x;
      if(y<minY) minY=y; if(y>maxY) maxY=y;
    });

    // Initial scale to fit canvas
    scale = Math.min(canvas.width/(maxX-minX), canvas.height/(maxY-minY));
    offsetX = -minX*scale;
    offsetY = -minY*scale;

    draw();
  });

// ---------------- ZOOM & PAN ----------------
canvas.addEventListener('wheel', e => {
  const delta = -e.deltaY/500;
  scale *= 1 + delta;
  draw();
});

canvas.addEventListener('mousedown', e => {
  isDragging = true;
  startDrag = {x:e.clientX, y:e.clientY, offsetX, offsetY};
});
canvas.addEventListener('mouseup', ()=> isDragging=false);
canvas.addEventListener('mouseout', ()=> isDragging=false);
canvas.addEventListener('mousemove', e => {
  if(isDragging){
    offsetX = startDrag.offsetX + e.clientX - startDrag.x;
    offsetY = startDrag.offsetY + e.clientY - startDrag.y;
    draw();
  }

  if(!data) return;
  const mouseX = e.clientX, mouseY = e.clientY;
  let found = null;
  for(let f of data){
    const [cx, cy] = mercatorXY(f.lat, f.lon);
    const size = 13*1000; // approx cell size in meters
    const px = cx*scale + offsetX;
    const py = canvas.height - (cy*scale + offsetY);
    if(mouseX>=px-size/2 && mouseX<=px+size/2 && mouseY>=py-size/2 && mouseY<=py+size/2){
      found = f; break;
    }
  }
  if(found){
    tooltip.style.display='block';
    tooltip.style.left = (e.clientX+10)+'px';
    tooltip.style.top = (e.clientY+10)+'px';
    tooltip.innerHTML = `Prob: ${(found.prob*100).toFixed(1)}%`;
  } else {
    tooltip.style.display='none';
  }
});

// ---------------- DRAW ----------------
function draw(){
  if(!data) return;
  ctx.clearRect(0,0,canvas.width,canvas.height);

  for(let f of data){
    const [cx, cy] = mercatorXY(f.lat, f.lon);
    const px = cx*scale + offsetX;
    const py = canvas.height - (cy*scale + offsetY);

    // Approximate Mercator cell size in pixels
    const size = 13*1000*scale;

    // Color
    const red = Math.floor(255*f.prob);
    const blue = Math.floor(255*(1-f.prob));
    ctx.fillStyle = `rgba(${red},0,${blue},0.7)`;

    // Draw polygon (square here, can replace with 4-corner polygon for more accuracy)
    ctx.beginPath();
    ctx.moveTo(px-size/2, py-size/2);
    ctx.lineTo(px+size/2, py-size/2);
    ctx.lineTo(px+size/2, py+size/2);
    ctx.lineTo(px-size/2, py+size/2);
    ctx.closePath();
    ctx.fill();
  }
}
</script>
</body>
</html>
