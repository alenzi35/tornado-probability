<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Chicago Test Cell (LCC)</title>
<style>
  body { margin:0; overflow:hidden; background:#000; }
  canvas { display:block; }
</style>
</head>
<body>
<canvas id="map"></canvas>

<script>
const canvas = document.getElementById("map");
const ctx = canvas.getContext("2d");

let scale = 1;
let offsetX = 0;
let offsetY = 0;
let dragging = false;
let lastX, lastY;

let cells = [];
let borders = [];

// Resize
function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  draw();
}
window.addEventListener("resize", resize);
resize();

// ---------------------------
// Lat/Lon → LCC conversion
// ---------------------------
function latLonToLCC(lat, lon) {
  const deg2rad = Math.PI / 180;

  // RAP LCC parameters
  const a = 6371229;
  const lat0 = 50 * deg2rad;
  const lon0 = 253 * deg2rad;  // 253°E
  const lat1 = 50 * deg2rad;
  const lat2 = 50 * deg2rad;

  const phi = lat * deg2rad;
  const lambda = lon * deg2rad;

  const n = Math.sin(lat1);
  const F = Math.cos(lat1) * Math.pow(Math.tan(Math.PI/4 + lat1/2), n) / n;
  const rho0 = a * F / Math.pow(Math.tan(Math.PI/4 + lat0/2), n);
  const rho = a * F / Math.pow(Math.tan(Math.PI/4 + phi/2), n);
  const theta = n * (lambda - lon0);

  const x = rho * Math.sin(theta);
  const y = rho0 - rho * Math.cos(theta);

  return { x, y };
}

// ---------------------------
// Chicago test cell
// ---------------------------
const chicagoLatLon = { lat: 41.8781, lon: -87.6298 };
const chicagoLCC = latLonToLCC(chicagoLatLon.lat, chicagoLatLon.lon);

cells = [{
  x: chicagoLCC.x,
  y: chicagoLCC.y,
  dx: 32463,  // RAP cell size
  dy: 32463,
  prob: 1
}];

// ---------------------------
// Load borders
// ---------------------------
fetch("map/data/borders_lcc.json")
  .then(r => r.json())
  .then(data => {
    borders = data.features;
    fitView();
    draw();
  })
  .catch(err => console.error("Error loading borders:", err));

// ---------------------------
// Auto-fit view
// ---------------------------
function fitView() {
  let minX = Infinity, maxX = -Infinity;
  let minY = Infinity, maxY = -Infinity;

  cells.forEach(c => {
    minX = Math.min(minX, c.x);
    maxX = Math.max(maxX, c.x + c.dx);
    minY = Math.min(minY, c.y);
    maxY = Math.max(maxY, c.y + c.dy);
  });

  borders.forEach(line => {
    line.forEach(([x,y]) => {
      minX = Math.min(minX, x);
      maxX = Math.max(maxX, x);
      minY = Math.min(minY, y);
      maxY = Math.max(maxY, y);
    });
  });

  const w = maxX - minX;
  const h = maxY - minY;
  const sx = canvas.width / w;
  const sy = canvas.height / h;

  scale = Math.min(sx, sy) * 0.9; // small margin
  offsetX = canvas.width/2 - (minX + w/2) * scale;
  offsetY = canvas.height/2 + (minY + h/2) * scale;
}

// ---------------------------
// Draw
// ---------------------------
function draw() {
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);

  ctx.setTransform(scale, 0, 0, -scale, offsetX, offsetY);

  // Cells
  cells.forEach(c => {
    const r = Math.floor(255 * c.prob);
    const b = 255 - r;
    ctx.fillStyle = `rgb(${r},0,${b})`;
    ctx.fillRect(c.x, c.y, c.dx, c.dy);
  });

  // Borders
  ctx.lineWidth = 1/scale;
  ctx.strokeStyle = "white";
  ctx.beginPath();

  borders.forEach(line => {
    line.forEach(([x,y], i) => {
      if(i===0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    });
  });

  ctx.stroke();
}

// ---------------------------
// Zoom
// ---------------------------
canvas.addEventListener("wheel", e => {
  e.preventDefault();
  const zoom = e.deltaY < 0 ? 1.15 : 0.87;
  const mx = e.offsetX;
  const my = e.offsetY;
  offsetX = mx - zoom*(mx - offsetX);
  offsetY = my - zoom*(my - offsetY);
  scale *= zoom;
  draw();
});

// ---------------------------
// Pan
// ---------------------------
canvas.addEventListener("mousedown", e => {
  dragging = true;
  lastX = e.clientX;
  lastY = e.clientY;
});
window.addEventListener("mouseup", () => dragging = false);
window.addEventListener("mousemove", e => {
  if (!dragging) return;
  offsetX += e.clientX - lastX;
  offsetY += e.clientY - lastY;
  lastX = e.clientX;
  lastY = e.clientY;
  draw();
});
</script>
</body>
</html>
