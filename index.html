<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>LCC Tornado Map</title>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #111;
    }

    canvas {
      display: block;
    }

    #info {
      position: fixed;
      top: 10px;
      left: 10px;
      color: white;
      font-family: monospace;
      background: rgba(0,0,0,0.6);
      padding: 6px 10px;
      border-radius: 4px;
    }
  </style>
</head>

<body>

<canvas id="map"></canvas>
<div id="info">Loadingâ€¦</div>

<script>

const canvas = document.getElementById("map");
const ctx = canvas.getContext("2d");
const info = document.getElementById("info");

let W, H;

// View state
let scale = 1;
let offsetX = 0;
let offsetY = 0;

let borders = [];
let testCell = null;


// -------------------------
// Resize
// -------------------------

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  draw();
}

window.addEventListener("resize", resize);
resize();


// -------------------------
// Pan + Zoom
// -------------------------

let dragging = false;
let lastX = 0;
let lastY = 0;

canvas.addEventListener("mousedown", e => {
  dragging = true;
  lastX = e.clientX;
  lastY = e.clientY;
});

window.addEventListener("mouseup", () => {
  dragging = false;
});

window.addEventListener("mousemove", e => {
  if (!dragging) return;

  offsetX += e.clientX - lastX;
  offsetY += e.clientY - lastY;

  lastX = e.clientX;
  lastY = e.clientY;

  draw();
});

canvas.addEventListener("wheel", e => {
  e.preventDefault();

  const zoom = e.deltaY < 0 ? 1.15 : 0.85;

  const mx = e.clientX;
  const my = e.clientY;

  offsetX = mx - (mx - offsetX) * zoom;
  offsetY = my - (my - offsetY) * zoom;

  scale *= zoom;

  draw();
}, { passive: false });


// -------------------------
// Load Borders
// -------------------------

fetch("/map/data/borders_lcc.json")
  .then(r => r.json())
  .then(data => {

    borders = data.features;

    console.log("Loaded borders:", borders.length);

    fitView();
    createTestCell();
    draw();

    info.textContent = "Borders loaded";

  })
  .catch(err => {

    console.error("Failed to load borders:", err);
    info.textContent = "Failed to load borders";

  });


// -------------------------
// Create Test Cell (Chicago-ish LCC point)
// -------------------------

function createTestCell() {

  // Example LCC coords (replace later with real conversion)
  testCell = {
    x: -920000,
    y: 190000,
    size: 30000
  };

}


// -------------------------
// Fit View
// -------------------------

function fitView() {

  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;

  for (const f of borders) {

    for (const ring of f.geometry.coordinates) {
      for (const [x,y] of ring) {

        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);

      }
    }
  }

  const mapW = maxX - minX;
  const mapH = maxY - minY;

  scale = Math.min(W / mapW, H / mapH) * 0.9;

  offsetX = W/2 - (minX + mapW/2) * scale;
  offsetY = H/2 - (minY + mapH/2) * scale;
}


// -------------------------
// Draw
// -------------------------

function draw() {

  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,W,H);

  ctx.setTransform(
    scale,
    0,
    0,
    -scale,
    offsetX,
    H + offsetY
  );

  drawBorders();
  drawTestCell();

}


// -------------------------
// Borders
// -------------------------

function drawBorders() {

  ctx.strokeStyle = "white";
  ctx.lineWidth = 1 / scale;

  for (const f of borders) {

    ctx.beginPath();

    for (const ring of f.geometry.coordinates) {

      ring.forEach(([x,y], i) => {

        if (i === 0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);

      });

      ctx.closePath();
    }

    ctx.stroke();
  }

}


// -------------------------
// Test Cell
// -------------------------

function drawTestCell() {

  if (!testCell) return;

  const s = testCell.size;

  ctx.fillStyle = "red";
  ctx.strokeStyle = "yellow";
  ctx.lineWidth = 2 / scale;

  ctx.beginPath();

  ctx.rect(
    testCell.x - s/2,
    testCell.y - s/2,
    s,
    s
  );

  ctx.fill();
  ctx.stroke();

}


</script>
</body>
</html>
